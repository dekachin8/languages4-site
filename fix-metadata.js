/**
 * Languages 4 Metadata Fixer Script - BATCH VERSION
 * Processes all HTML files in blog directory and adds JSON-LD metadata
 */

import fs from "fs";
import path from "path";
import { JSDOM } from "jsdom";
import Anthropic from "@anthropic-ai/sdk";

const CONFIG = {
  inputDir: "D:\\l4-site\\blog",
  outputDir: "D:\\l4-site\\blog_fixed",
  delayBetweenFiles: 1000, // 1 second delay between API calls
};

const anthropic = new Anthropic({
  apiKey: process.env.ANTHROPIC_API_KEY,
});

function hasJSONLD(html) {
  const dom = new JSDOM(html);
  const scripts = dom.window.document.querySelectorAll(
    'script[type="application/ld+json"]'
  );
  for (let script of scripts) {
    try {
      const data = JSON.parse(script.textContent);
      if (data["@type"] === "Article") return true;
    } catch (e) {}
  }
  return false;
}

function extractBasicMetadata(html) {
  const dom = new JSDOM(html);
  const doc = dom.window.document;
  const getMeta = (name) => {
    const meta = doc.querySelector(
      `meta[name="${name}"], meta[property="${name}"]`
    );
    return meta ? meta.getAttribute("content") : "";
  };
  return {
    title: getMeta("title") || doc.querySelector("title")?.textContent || "",
    description: getMeta("description") || "",
    ogImage: getMeta("og:image") || "",
    ogImageAlt: getMeta("og:image:alt") || "",
  };
}

function extractArticleContent(html) {
  const dom = new JSDOM(html);
  const doc = dom.window.document;
  const contentDiv =
    doc.querySelector(".col-lg-8") || doc.querySelector("main") || doc.body;
  const elementsToRemove = contentDiv.querySelectorAll(
    "nav, footer, script, style, .col-lg-4, aside, .sidebar"
  );
  elementsToRemove.forEach((el) => el.remove());
  return contentDiv.textContent.trim().slice(0, 8000);
}

function extractDateFromFilename(filename) {
  // Match patterns like 4.28.24 or 10.23.23 in filename
  const match = filename.match(/(\d{1,2})\.(\d{1,2})\.(\d{2,4})/);
  if (match) {
    let [, month, day, year] = match;
    if (year.length === 2) {
      year = parseInt(year) > 50 ? `19${year}` : `20${year}`;
    }
    return `${year}-${month.padStart(2, "0")}-${day.padStart(2, "0")}`;
  }
  return null;
}

async function generateMetadataWithAI(articleContent, basicMeta, filename) {
  const dateFromFilename = extractDateFromFilename(filename);

  const prompt = `You are helping to generate SEO metadata for Indigenous language revitalization blog articles.

Article Title: ${basicMeta.title}
${basicMeta.description ? `Existing Description: ${basicMeta.description}` : ""}
${dateFromFilename ? `Publication Date: ${dateFromFilename}` : ""}

Article Content (truncated):
${articleContent}

Please generate JSON-LD metadata in this EXACT format (valid JSON only, no markdown):

{
  "@context": "https://schema.org",
  "@type": "Article",
  "headline": "exact article title here",
  "description": "compelling 150-180 character SEO description here",
  "image": "${
    basicMeta.ogImage ||
    "https://www.languages4.com/pages/assets/img/logo_languages4.webp"
  }",
  "author": {
    "@type": "Person",
    "name": "Tim O'Hagan",
    "jobTitle": "Founder & President",
    "email": "tim@languages4.com",
    "affiliation": {
      "@type": "Organization",
      "name": "Languages 4"
    }
  },
  "publisher": {
    "@type": "Organization",
    "name": "Languages 4",
    "logo": {
      "@type": "ImageObject",
      "url": "https://www.languages4.com/pages/assets/img/logo_languages4.webp"
    }
  },
  "datePublished": "${
    dateFromFilename || new Date().toISOString().split("T")[0]
  }",
  "dateModified": "${
    dateFromFilename || new Date().toISOString().split("T")[0]
  }",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://www.languages4.com/blog/${filename}"
  },
  "keywords": [
    "keyword1",
    "keyword2"
  ]
}

IMPORTANT: Generate 10-12 highly relevant keywords about Indigenous language revitalization, cultural curriculum, and the specific topics in this article. Return ONLY valid JSON, no markdown.`;

  const message = await anthropic.messages.create({
    model: "claude-sonnet-4-20250514",
    max_tokens: 1500,
    messages: [{ role: "user", content: prompt }],
  });

  let jsonText = message.content[0].text.trim();
  if (jsonText.startsWith("```")) {
    jsonText = jsonText.replace(/```json\n?/g, "").replace(/```\n?/g, "");
  }

  const metadata = JSON.parse(jsonText);
  return metadata;
}

function insertJSONLD(html, jsonld) {
  const headCloseIndex = html.indexOf("</head>");
  if (headCloseIndex === -1) throw new Error("Could not find </head> tag");

  const jsonldScript = `
    <!-- ===============================================-->
    <!--    JSON-LD (Generated by AI)                   -->
    <!-- ===============================================-->

    <script type="application/ld+json">
    ${JSON.stringify(jsonld, null, 2)}
    </script>

`;
  return (
    html.slice(0, headCloseIndex) + jsonldScript + html.slice(headCloseIndex)
  );
}

function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

async function processFile(inputPath, outputPath) {
  const filename = path.basename(inputPath);

  const html = fs.readFileSync(inputPath, "utf-8");

  if (hasJSONLD(html)) {
    // Copy file as-is if it already has JSON-LD
    fs.writeFileSync(outputPath, html, "utf-8");
    return { status: "skipped", reason: "already has JSON-LD" };
  }

  const basicMeta = extractBasicMetadata(html);
  const articleContent = extractArticleContent(html);

  const jsonld = await generateMetadataWithAI(
    articleContent,
    basicMeta,
    filename
  );

  const updatedHtml = insertJSONLD(html, jsonld);
  fs.writeFileSync(outputPath, updatedHtml, "utf-8");

  return {
    status: "processed",
    headline: jsonld.headline,
    keywords: jsonld.keywords?.length || 0
  };
}

async function main() {
  console.log("=====================================");
  console.log("Languages 4 Metadata Fixer - BATCH MODE");
  console.log("=====================================\n");

  // Create output directory
  if (!fs.existsSync(CONFIG.outputDir)) {
    fs.mkdirSync(CONFIG.outputDir, { recursive: true });
    console.log(`Created output directory: ${CONFIG.outputDir}\n`);
  }

  // Get all HTML files
  const files = fs.readdirSync(CONFIG.inputDir)
    .filter(f => f.endsWith(".html"));

  console.log(`Found ${files.length} HTML files to process\n`);

  const results = {
    processed: 0,
    skipped: 0,
    errors: []
  };

  for (let i = 0; i < files.length; i++) {
    const filename = files[i];
    const inputPath = path.join(CONFIG.inputDir, filename);
    const outputPath = path.join(CONFIG.outputDir, filename);

    console.log(`[${i + 1}/${files.length}] ${filename}`);

    try {
      const result = await processFile(inputPath, outputPath);

      if (result.status === "skipped") {
        console.log(`   ⏭️  Skipped (${result.reason})`);
        results.skipped++;
      } else {
        console.log(`   ✅ Generated: ${result.keywords} keywords`);
        results.processed++;
      }

      // Rate limiting - wait between API calls
      if (result.status === "processed" && i < files.length - 1) {
        await sleep(CONFIG.delayBetweenFiles);
      }
    } catch (error) {
      console.log(`   ❌ Error: ${error.message}`);
      results.errors.push({ file: filename, error: error.message });
    }
  }

  console.log("\n=====================================");
  console.log("SUMMARY");
  console.log("=====================================");
  console.log(`✅ Processed: ${results.processed}`);
  console.log(`⏭️  Skipped:   ${results.skipped}`);
  console.log(`❌ Errors:    ${results.errors.length}`);

  if (results.errors.length > 0) {
    console.log("\nErrors:");
    results.errors.forEach(e => console.log(`  - ${e.file}: ${e.error}`));
  }

  console.log(`\nOutput saved to: ${CONFIG.outputDir}`);
}

main().catch((error) => {
  console.error("Fatal error:", error);
  process.exit(1);
});
